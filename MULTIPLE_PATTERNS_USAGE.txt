================================================================================
    MULTIPLE DESIGN PATTERNS USED TOGETHER - USE CASES
================================================================================

This document identifies where multiple design patterns are integrated and 
working together in the AI Shopping Assistant application.

================================================================================
USE CASE 1: DISCOUNT CALCULATOR KNOWLEDGE SOURCE
================================================================================

Location: backend/architecture/knowledgeSources/KnowledgeSources.js
Lines: 56-82

PATTERNS USED TOGETHER:
1. Interpreter Pattern
2. Composite Pattern  
3. Visitor Pattern

DESCRIPTION:
The Discount Calculator Knowledge Source combines THREE patterns in a single
operation to calculate and apply discounts to shopping carts.

HOW THEY WORK TOGETHER:

Step 1 - INTERPRETER PATTERN:
  - Creates a ShoppingContext from user, cart, and inventory
  - This context is used to evaluate discount conditions
  - Conditions like PriceCondition, UserAttributeExpression are interpreted

Step 2 - COMPOSITE PATTERN:
  - discountRules is a composite structure of discount rules
  - Rules can be nested (e.g., student discount + cart value discount)
  - Allows combining multiple discount strategies hierarchically

Step 3 - VISITOR PATTERN:
  - DiscountVisitor traverses the shopping cart
  - Visits each cart item and applies eligible discount rules
  - Returns aggregated discount results

CODE FLOW:
  const shoppingContext = new ShoppingContext(user, cart, inventory);
  // Interpreter creates context ↑
  
  const discountVisitor = new DiscountVisitor(this.discountRules, shoppingContext);
  // Visitor uses Composite discount rules ↑
  
  const result = discountVisitor.visitShoppingCart(cart);
  // Visitor pattern traverses cart and applies discounts ↑

REAL-WORLD EXAMPLE:
When a student with $120 in their cart checks out:
- Interpreter evaluates: user.isStudent === true (✓)
- Interpreter evaluates: cart.total >= 100 (✓)
- Composite applies: 15% student discount + 10% high-value cart discount
- Visitor traverses cart items and calculates final discount amount

================================================================================
USE CASE 2: DISCOUNT RULES INITIALIZATION
================================================================================

Location: backend/services/ShoppingAssistantService.js
Lines: 48-75

PATTERNS USED TOGETHER:
1. Composite Pattern
2. Interpreter Pattern

DESCRIPTION:
When creating discount rules, the Composite pattern builds hierarchical 
discount structures, while Interpreter pattern defines the conditions.

HOW THEY WORK TOGETHER:

COMPOSITE PATTERN:
  - DiscountBuilder creates composite discount structures
  - Discounts can be nested with different operators (SUM, MAX, AND)
  - Parent discounts contain child discount rules

INTERPRETER PATTERN:
  - Each discount has conditions expressed as interpreter expressions
  - UserAttributeExpression: interprets user properties
  - PriceCondition: interprets cart total
  - TimeBasedCondition: interprets date/time
  - CategoryCondition: interprets product categories

CODE EXAMPLE:
  const studentDiscount = builder
      .createComposite('Student & Cart Combo', 'SUM')  // COMPOSITE
      .addPercentage('Student Discount', 15, 
          new UserAttributeExpression('isStudent', '===', true))  // INTERPRETER
      .addPercentage('High Value Cart', 10, 
          new PriceCondition(100))  // INTERPRETER
      .build();

STRUCTURE:
  Composite Discount (SUM)
    ├─ Student Discount (15%)
    │    └─ Condition: UserAttributeExpression (isStudent === true)
    └─ High Value Cart (10%)
         └─ Condition: PriceCondition (total >= 100)

REAL-WORLD EXAMPLE:
Electronics Bundle discount:
- COMPOSITE: MAX operator chooses best discount
  - Option A: 20% off electronics (if buying 2+ electronics)
  - Option B: Buy 2 Get 1 Free on electronics
- INTERPRETER: Evaluates conditions for each option
  - CategoryCondition checks electronics count
  - System applies whichever gives maximum savings

================================================================================
USE CASE 3: CART EVALUATION PIPELINE
================================================================================

Location: backend/services/ShoppingAssistantService.js
Lines: 117-150 (addToCart method)

PATTERNS USED TOGETHER:
1. State Pattern
2. Visitor Pattern
3. Blackboard Architecture

DESCRIPTION:
When adding items to cart, multiple patterns coordinate to manage session
state, cart operations, and knowledge processing.

HOW THEY WORK TOGETHER:

STATE PATTERN:
  - Session has different states (Browsing, InCart, Checkout, Completed)
  - Only certain operations allowed in each state
  - addToCart() transitions from Browsing → InCart

VISITOR PATTERN:
  - CartItem objects are created for each product
  - Cart visitors can traverse and process these items
  - Allows operations like discount calculation, validation, etc.

BLACKBOARD ARCHITECTURE:
  - Multiple Knowledge Sources react to cart changes
  - Each KS contributes specialized knowledge:
    * DiscountCalculator (uses Visitor + Interpreter)
    * CartOptimizer (suggests improvements)
    * InventoryChecker (validates stock)
    * PersonalizationEngine (updates recommendations)

CODE FLOW:
  1. State Pattern validates operation is allowed
     session.addToCart(cartItem) → checks current state
  
  2. Visitor Pattern creates cart structure
     const cartItem = new CartItem(productId, name, price, quantity, ...)
  
  3. Blackboard notifies all Knowledge Sources
     this.blackboard.setCart(userId, cart)
     → Triggers all registered Knowledge Sources
  
  4. Each KS processes independently:
     - DiscountCalculator applies discounts (uses Interpreter + Composite)
     - Inventory checker validates stock
     - Personalization updates recommendations

REAL-WORLD EXAMPLE:
User adds "Laptop ($1200)" to cart:
1. STATE: Session transitions from Browsing → InCart state
2. VISITOR: CartItem created with laptop details
3. BLACKBOARD: Cart update triggers all Knowledge Sources
   - DiscountCalculatorKS: Checks if electronics discount applies
   - InventoryCheckerKS: Verifies laptop in stock
   - PersonalizationKS: Suggests laptop accessories
   - CartOptimizerKS: Recommends adding mouse to qualify for bundle discount

================================================================================
USE CASE 4: RULE EVALUATION ENGINE
================================================================================

Location: backend/architecture/ruleEngine/RuleEngine.js

PATTERNS USED TOGETHER:
1. Interpreter Pattern
2. Strategy Pattern (Forward/Backward Chaining)

DESCRIPTION:
The Rule Engine uses interpreter to evaluate rule conditions while strategy
pattern determines the inference approach.

HOW THEY WORK TOGETHER:

INTERPRETER PATTERN:
  - Rules have conditions expressed as interpreter syntax trees
  - Each condition (AND, OR, NOT) is an expression that can be evaluated
  - Variables, operators, and functions form the grammar

STRATEGY PATTERN:
  - InferenceEngine can use different strategies:
    * Forward Chaining: Start with facts, derive conclusions
    * Backward Chaining: Start with goal, prove facts
  - Strategy selected at initialization: new InferenceEngine(ruleBase, 'FORWARD')

CODE FLOW:
  1. Strategy determines evaluation order
     this.inferenceEngine.forwardChain(context)
  
  2. Interpreter evaluates each rule condition
     rule.condition.interpret(context)
  
  3. Results stored and next rules evaluated
     Continue until no new facts derived or max iterations

REAL-WORLD EXAMPLE:
Student discount rule evaluation:
- STRATEGY: Forward chaining selected
- INTERPRETER: Evaluates conditions in sequence:
  1. user.isStudent === true (✓)
  2. cart.total >= 50 (✓)
  3. time.month === 12 (✗)
- Result: First two conditions met, student discount applies

================================================================================
USE CASE 5: PERSONALIZATION ENGINE
================================================================================

Location: backend/architecture/knowledgeSources/KnowledgeSources.js
Lines: 100-180

PATTERNS USED TOGETHER:
1. Strategy Pattern
2. Blackboard Architecture
3. Observer Pattern (implicit)

DESCRIPTION:
Multiple recommendation strategies work together through blackboard to
provide personalized suggestions.

HOW THEY WORK TOGETHER:

STRATEGY PATTERN:
  - Different recommendation strategies:
    * Purchase history-based recommendations
    * Browsing history recommendations
    * Cart-based recommendations
    * Trending/popular products
  - Each strategy scores products differently

BLACKBOARD ARCHITECTURE:
  - Strategies read from blackboard:
    * getUserData() → purchase history
    * getCart() → current cart
    * getAllInventory() → available products
  - Strategies write to blackboard:
    * setRecommendations() → personalized suggestions

OBSERVER PATTERN (implicit):
  - Knowledge Source observes blackboard changes
  - onBlackboardUpdate() triggered when data changes
  - Automatically re-evaluates recommendations

CODE FLOW:
  1. Multiple strategies generate recommendations
     - Strategy 1: Based on purchase history (score: 1.0)
     - Strategy 2: Based on browsing (score: 0.7)
     - Strategy 3: Based on cart items (score: 0.8)
  
  2. Results merged and de-duplicated
     this.removeDuplicates(recommendations)
  
  3. Sorted by score and stored in blackboard
     recommendations.sort((a, b) => b.score - a.score)

REAL-WORLD EXAMPLE:
User has:
- Purchased: iPhone last month
- Browsed: Laptop category
- Cart: Wireless mouse

Strategies generate:
1. Purchase-based: iPhone case, AirPods (score: 1.0)
2. Browsing-based: Dell Laptop, MacBook (score: 0.7)
3. Cart-based: Keyboard, Mouse Pad (score: 0.8)

Final recommendations (sorted by score):
1. iPhone case (1.0)
2. AirPods (1.0)
3. Keyboard (0.8)
4. Mouse Pad (0.8)
5. Dell Laptop (0.7)

================================================================================
SUMMARY: PATTERN INTEGRATION BENEFITS
================================================================================

1. MODULARITY
   - Each pattern handles specific responsibility
   - Patterns can be modified independently

2. FLEXIBILITY
   - New discount rules added without changing discount calculator
   - New recommendation strategies added without changing personalization engine

3. REUSABILITY
   - Visitor pattern reused for discounts, validation, reporting
   - Interpreter reused for rules, conditions, expressions

4. MAINTAINABILITY
   - Clear separation of concerns
   - Each pattern has well-defined interface

5. SCALABILITY
   - Add new Knowledge Sources to blackboard without affecting existing ones
   - Add new discount types to composite without changing visitors

================================================================================
KEY TAKEAWAY
================================================================================

Multiple patterns working together provide more powerful solutions than
single patterns alone. The key is ensuring each pattern handles its specific
responsibility while maintaining clean interfaces between patterns.

In this project:
- INTERPRETER defines "what to evaluate"
- COMPOSITE defines "how to combine"
- VISITOR defines "how to apply"
- STATE defines "when operations are allowed"
- BLACKBOARD defines "how knowledge is shared"

Together they create a flexible, maintainable, and scalable system.
